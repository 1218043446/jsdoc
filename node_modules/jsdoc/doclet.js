(function() {
    var plugin = require('jsdoc/plugin');
    
    exports.Doclet = Doclet;
    function Doclet(jsdoc, meta) {
        if (jsdoc !== '') {
            this.tags = this.parseTags(jsdoc);
        }
        else {
            this.tags = [];
        }
        
        plugin.manager.run('doclet', [this]);
    }
    
    Doclet.prototype.parseTags = function(commentSrc) {
        // tags have [title, type, pname, text]
        
        commentSrc = fixDescription( trim(commentSrc) );
        this.src = commentSrc;
        var tags = splitTags(commentSrc),
            tag;
            
        for (var i = 0, len = tags.length; i < len; i++) {
            tag = tags[i];
            if ( dict.hasOwnProperty(tag.title) ) {
                var def = dict[tag.title];
                if (typeof def.onTag === 'function') {
                    def.onTag(tag, this);
                }
            }
        }
        
        return tags;
    }
    
    var dict = {};
    dict.name = {
        has: ['value'],
        title: 'name',
        onTag: function(tag, doc) {
            tag.text = trim(tag.text);
            if (tag.text) doc.name = tag.text;
        }
    }
    
    dict.description = {
        has: ['value'],
        title: 'description',
        onTag: function(tag, doc) {
            tag.text = trim(tag.text);
            doc.description = tag.text;
        }
    }
    dict.desc = dict.description;
    
    dict['var'] = {
        has: ['value'],
        title: 'var',
        onTag: function(tag, doc) {
            doc.kind = 'var';
            dict.name.onTag(tag, doc); // trimmed here
        }
    };
    
    dict['example'] = {
        has: ['value'],
        title: 'example',
        onTag: function(tag, doc) {
            // do not trim, whitespace matters in examples
        }
    };
    
    dict['type'] = {
        has: ['value'],
        title: 'type',
        onTag: function(tag, doc) {
            tag.text = trim(tag.text);
            if ( /\{(.+?)\}/.test(tag.text) ) {
                tag.text = trim(RegExp.$1);
            }
        }
    };
    
    function trim(text, newlines) {
		if (!text) { return ''; }
		
		if (newlines) {
		    return text.replace(/^[\n\r\f]+|[\n\r\f]+$/g, '');
		}
		else {
		    return text.replace(/^\s+|\s+$/g, '');
		}
	}
	
	/**
	    Given the raw source of a jsdoc comment, splits it up into individual tags.
	    @returns An array of tags, like: [{title, text}], where the original src
	    would be like: "@title text"
	 */
	function parseParamText(tagSrc) {
		var pname, pdesc, poptional, pdefault;
		
		// like: pname, pname pdesc, or name - pdesc
		tagSrc.match(/^(\[[^\]]+\]|\S+)((?:\s*\-\s*|\s+)(\S[\s\S]*))?$/);
		pname = RegExp.$1;
		pdesc = RegExp.$3;

		if ( /^\[\s*(.+?)\s*\]$/.test(pname) ) {
			pname = RegExp.$1;
			poptional = true;
			
			if ( /^(.+?)\s*=\s*(.+)$/.test(pname) ) {
				pname = RegExp.$1;
				pdefault = RegExp.$2;
			}
		}
		return [pname, pdesc, poptional, pdefault];
	}
	
	function fixDescription(docletSrc) {
	    if (docletSrc && !/^\s*@/.test(docletSrc)) {
			docletSrc = '@description ' + docletSrc;
		}
		return docletSrc;
	}
	
	/**
	    Given the raw source of a jsdoc comment, splits it up into individual tags.
	    @returns An array of tags, like: [{title, text}], where the original src
	    would be like: "@title text"
	 */
	function splitTags(docletSrc) {
		var tagSrcs = [];
              
		// split out the basic tags, keep surrounding whitespace
		// like: @tagTitle tagBody
		docletSrc
		.replace(/^(\s*)@(\S)/gm, '$1\\@$2') // replace splitter ats with an arbitrary sequence
		.split('\\@')                        // then split on that arbitrary sequence
		.forEach(function($) {
		    if ($) {
		        var parsedTag = $.match(/^(\S+)(:?\s+(\S[\s\S]*))?/);
                
                if (parsedTag) {
                    var tagTitle = parsedTag[1],
                        tagText = parsedTag[2];

                    if (tagTitle) {
                        tagSrcs.push({
                            title: tagTitle.toLowerCase(),
                            text: tagText || ''
                        });
                    }
                }
            }
		});
		
		return tagSrcs;
	}
})();