(function() {

    var Narcissus = require('narcissus').Narcissus,
        Doclet = require('jsdoc/doclet').Doclet;
    
    
    // handle orphaned doclets, associated with no code token
    Narcissus.parser.Tokenizer.prototype.onJsDoc = function(doclet, meta) {
        handle.JSDOC(doclet);
    }
             
    var path,
        symbols = 'wtf';
            
    exports.parse = function(src) {
        symbols = [];
        
        // may call handle.JSDOC
        var ast = Narcissus.parser.parse(src, '', 1);
//console.log(String(ast));
        path = [];

        walk(ast.children);
        
        return symbols;
    }
    
    function defined(o) {
        return typeof o !== 'undefined';
    }
    
    function typeToName(type) {
        var name;
        if (name = typeToName.types[type]) {
            return name;
        }
        return type;
    }
    typeToName.types = ['END', 'NEWLINE', 'SEMICOLON', 'COMMA', 'ASSIGN', 'HOOK', 'COLON', 'CONDITIONAL', 'OR', 'AND', 'BITWISE_OR', 'BITWISE_XOR', 'BITWISE_AND', 'EQ', 'NE', 'STRICT_EQ', 'STRICT_NE', 'LT', 'LE', 'GE', 'GT', 'LSH', 'RSH', 'URSH', 'PLUS', 'MINUS', 'MUL', 'DIV', 'MOD', 'NOT', 'BITWISE_NOT', 'UNARY_PLUS', 'UNARY_MINUS', 'INCREMENT', 'DECREMENT', 'DOT', 'LEFT_BRACKET', 'RIGHT_BRACKET', 'LEFT_CURLY', 'RIGHT_CURLY', 'LEFT_PAREN', 'RIGHT_PAREN', 'SCRIPT', 'BLOCK', 'LABEL', 'FOR_IN', 'CALL', 'NEW_WITH_ARGS', 'INDEX', 'ARRAY_INIT', 'OBJECT_INIT', 'PROPERTY_INIT', 'GETTER', 'SETTER', 'GROUP', 'LIST', 'LET_BLOCK', 'ARRAY_COMP', 'GENERATOR', 'COMP_TAIL', 'IDENTIFIER', 'NUMBER', 'STRING', 'REGEXP', 'BREAK', 'CASE', 'CATCH', 'CONST', 'CONTINUE', 'DEBUGGER', 'DEFAULT', 'DELETE', 'DO', 'ELSE', 'EXPORT', 'FALSE', 'FINALLY', 'FOR', 'FUNCTION', 'IF', 'IMPORT', 'IN', 'INSTANCEOF', 'LET', 'MODULE', 'NEW', 'NULL', 'RETURN', 'SWITCH', 'THIS', 'THROW', 'TRUE', 'TRY', 'TYPEOF', 'VAR', 'VOID', 'YIELD', 'WHILE', 'WITH'];
    
    var handle = {
        JSDOC: function(jsdoc) {
            //console.log( '>>> jsdoc "'+jsdoc+'"' );
             symbols.push( new Doclet(jsdoc, {longname: ''}) );
        },
        VAR: function(node) {
            var child = null,
                varDoc = defined(node.jsdoc)? node.jsdoc : '';
                
            while ( child = node.children.shift() ) {
                if (varDoc) {
                    child.jsdoc = varDoc;
                    varDoc = null;
                }
                
                if (child.initializer ) {
                    // like var foo = function
                    if ( typeToName(child.initializer.type) === 'FUNCTION' ) {
                        // treat this var node as a function
                        child.initializer.name = child.name;
                        return handle.FUNCTION( child.initializer );
                    }
                }
                
                var namePath = path.join('') + (path.length?'~':'') + child.name;

                symbols.push(
                    defined(child.jsdoc)?
                        new Doclet(child.jsdoc, {longname: namePath, kind: 'var'})
                        : new Doclet('', {longname: namePath, kind: 'var'})
                );
                
                var children = walkable(child);
                if (children) { walk(children); }
            }
        },
        FUNCTION: function(node) {
            var namePath = path.join('') + (path.length?'~':'') + node.name,
                jsdoc = defined(node.jsdoc)? node.jsdoc : '';
            
            symbols.push( new Doclet(jsdoc, {longname: namePath, kind: 'function'}) );
            //console.log( '>>> function '+namePath+(defined(node.jsdoc)? ' "'+node.jsdoc+'"' : '') );
            path.push((path.length?'~':'')+node.name);
            walk(node.body.children);
            path.pop();
        },
        OBJECT_INIT: function(node) {
            console.log( '>>> TODO object literal '+node.name+' '+node.jsdoc);
            
        }
        
    };
        
    function walk(ast) {
        var node = null,
            nodeType = -1;

        while (node = ast.shift()) {
            nodeType = typeToName(node.type);

            if (handle.hasOwnProperty(nodeType) && typeof handle[nodeType] === 'function') {
                handle[nodeType](node);
            }
            else if (node.jsdoc) {
                handle.JSDOC(node.jsdoc);
            }

            var children = walkable(node);
            if (children) { walk(children); }
        }
    }
    
    function walkable(node) {
        //console.log('>>> getting walkables of: '+typeToName(node.type)+' '+node.name);
        if ( defined(node.body) && defined(node.body.children) && node.body.children !== null) {
            //console.log('- has body/children');
            return node.body.children;
        }
        if ( defined(node.expression) && node.expression && defined(node.expression.children) && node.expression.children ) {
            //console.log('- has expression/children');
            return node.expression.children;
        }
        // like: foo = function(){}
        if ( defined(node.initializer)) {
            //console.log('- has initializer');
            if (typeToName(node.initializer.type) === 'FUNCTION') {
                //console.log('- has function value');
                path.push((path.length?'~':'')+node.name);
                return(node.initializer.body.children);
            }
            else if (typeToName(node.initializer.type) === 'OBJECT_INIT') {
                //console.log('- has object value');
                path.push('~'+node.name);
                return(node.initializer.children);
            }
            // like foo = /**doc*/{};
            else if (node.initializer.jsdoc) {
                handle.JSDOC(node.initializer.jsdoc);
            }
        }
        if ( defined(node.children) ) {
            //console.log('- has children '+node.children.length);
            return node.children;
        }
        //console.log('nothing to walk');
    }

    
})();